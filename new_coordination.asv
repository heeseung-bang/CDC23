function new_coordination(n)

    global CAVs th delta;
    global u_min u_max v_min v_max;
    
    traj = [0,0,0; 0,0,0];  % [Phis1;Phis2]
    CAVs{n}.phis = traj;
        
    v0 = CAVs{n}.v0;
    vf = CAVs{n}.vf;
    v_mean = (v0+vf)/2;
    tf = CAVs{n}.tf;
    sf = CAVs{n}.geometry.length;
    
    CPs = CAVs{n}.geometry.adjacency;
    
    for idx = 1:length(CPs)     % for each CP, we find CAV with possible collision
        cp = CPs(idx);
        for p = 1:(n-1)
            if CAVs{p}.exited || CAVs{p}.path ~= cp
                continue;
            end
            n_idx = find(CAVs{n}.geometry.adjacency == cp);
            p_idx = find(CAVs{p}.geometry.adjacency == CAVs{n}.path);
            snc = CAVs{n}.geometry.conflictDist(n_idx); % location of the conflict point for CAV n
            tpc = CAVs{p}.time(p_idx);  % time when CAV p arriving to the conflict point
            dt = CAVs{n}.t0 - CAVs{p}.t0;
            candidate = [tpc-dt-th, tpc-dt+th];   % These are candidates for a waypoint
            for tnc_idx = 1:2
                tnc = candidate(tnc_idx);
                vc = v_mean; % maybe vc is not important!
                if new_isFeasible(vc,n,p)
                    % co
                    CAVs{n}.tc = tnc;
                    CAVs{n}.vc = vc1;
                    CAVs{n}.phis = traj;
                    return;
                end
            end
            % if current choice didn't work, we can try for next 'p'
        end
    end
end




% clc;
% 
% global CAVs prev_CAV th delta;
% global u_min u_max v_min v_max;
% 
% X = sol.x;
% % v = 9 % this should be the same as one in trip_generation.m
% 
% % CAVs structure
% cav_fields = {'t0','v0','tf','vf','phis','path','exited','geometry','time'};
% cav_cell = cell(length(cav_fields),1);
% cav_info = cell2struct(cav_cell,cav_fields);
% clear("cav_fields","cav_cell");
% 
% cav_info.exited = false;
% v_min = 0.15;
% v_max = 25;
% u_max = 5;
% u_min = -5;
% 
% delta = 6;  % safety distance [m] for rear-end safety
% th = 2;     % Time headway [s] for lateral safety
% 
% N = length(trip);
% % V0 = trip(:,4).*(1.5*ones([N,1])-1*rand([N,1]));
% path = [0,1,2,3;6,0,4,5;8,9,0,7;10,11,12,0]; % path(inDir,outDir) -> 1~12
% 
% CAVs = cell(N,1);
% prev_tf = zeros([4,1]); % saving the last exiting time at each direction (1~4)
% 
% for n = 1:N
%     
%     % Save newly entering CAV n
%     CAVs{n} = cav_info;
%     CAVs{n}.t0 = trip(n,1);
%     CAVs{n}.v0 = V0(n);
%     CAVs{n}.path = path(trip(n,2),trip(n,3)-4);
%     CAVs{n}.geometry = getGeometry(CAVs{n}.path,2*(L+rw),rw);
%     
%     % Check exited CAVs
%     for i = 1:(n-1)
%         if CAVs{i}.t0 + CAVs{i}.tf < CAVs{n}.t0
%             CAVs{i}.exited = true;
%         end
%     end
%     
%     % Estimate travel time and Fix arrival time
%     flow_in = sum(X(:,8*(v-1)+trip(n,2)));
%     flow_out = sum(X(:,8*(v-1)+trip(n,3)));
%     bpr_in = t0*(1+0.15*(flow_in/gamma)^4);
%     bpr_out = t0*(1+0.15*(flow_out/gamma)^4);
%     
%     tf1 = trip(n,1) + bpr_in + bpr_out;
%     ft2 = prev_tf(trip(n,3)-4) + 1/flow_out;
%     CAVs{n}.tf = max(tf1,tf2) - CAVs{n}.t0;
%     prev_tf(trip(n,3)-4) = CAVs{n}.tf + CAVs{n}.t0;
%     
%     v0 = CAVs{n}.v0;
%     tf = CAVs{n}.tf;
%     sf = CAVs{n}.geometry.length;
%     
%     %%%%%%%%%%%%%%%%%%%%%% START COORDINATION %%%%%%%%%%%%%%%%%%%%%%
%     fprintf('=========================\n');
%     fprintf('CAV %d\n',n);
%     fprintf('Path: %d\n',CAVs{n}.path);
%     fprintf('-------------------------\n');
%     
%     CPs = CAVs{n}.geometry.adjacency;
%     
%     for idx = 1:length(CPs)     % for each CP, we find CAV with possible collision
%         cp = CPs(idx);
%         for p = 1:(n-1)
%             if CAVs{p}.exited
%                 continue;
%             elseif CAVs{p}.path == cp
%                 n_idx = find(CAVs{n}.geometry.adjacency == cp);
%                 p_idx = find(CAVs{p}.geometry.adjacency == CAVs{n}.path);
%                 snc = CAVs{n}.geometry.conflictDist(n_idx); % location of the conflict point for CAV n
%                 tpc = CAVs{p}.time(p_idx);  % time when CAV p arriving to the conflict point
%                 dt = CAVs{n}.t0 - CAVs{p}.t0;
%                 candidate = [tpc-dt-th, tpc-dt+th];   % These are candidates for a waypoint
%                 for tnc_idx = 1:2
%                     tnc = candidate(tnc_idx);
%                     for vc = v_max:-0.1:v_min
%                         % Check lateral safety
%                         vec1 = [3*tnc^2,2*tnc; tnc^3,tnc^2]\[vc-v0;snc-v0*tnc]; % trajectory 1
%                         diff_tnf = tf-tnc;
%                         vec2 = [3*diff_tnf^2,2*diff_tnf; diff_tnf^3,diff_tnf^2]\[vf-vc;sf-vc*diff_tnf]; % trajectory 2
%                         for i=1:idx-1
%                             for pp = 1:(n-1)
%                                 if pp == p
%                                     continue;
%                                 end
%                                 pp_idx = find(CAVs{pp}.geometry.adjacency == CAVs{n}.path);
%                                 tppc = CAVs{pp}.time(pp_idx);
%                                 dt_pp = CAVs{n}.t0 - CAVs{pp}.t0;
%                                 if abs(tppc-dt_pp)
%                             end
%                         end
%                         for i=idx+1:length(CPs)
%                         end
%                         if unsafe
%                             continue;
%                         end
%                         % Check rear-end safety
%                         if unsafe
%                             continue;
%                         end
%                         % If all satisfied, select the current point as a waypoint
%                         done = true;
%                     end
%                     if done
%                         break;
%                     end
%                 end
%             end
%             if done
%                 break;
%             end
%         end
%         if done
%             break;
%         end
%     end
%     % consider the case where n == 1
%     % In other case, save CAVs{n}.time for all CPs
% 
% end
% 
% 
% 
% 
% 